Sequ_101:
module seq_101_moore(input clk,rst,din,output dout);
parameter idle=2'b00;
parameter s1=2'b01;
parameter s2=2'b10;
parameter s3=2'b11;
reg [1:0]ns,ps;
always@(posedge clk)
begin
if(rst)
ps<=idle;
else
ps<=ns;
end
//next state logic
always@(*)
begin
case(ps)
idle:begin
     if(din)
     ns=s1;
     else
     ns=idle;
     end
s1:begin
   if(din)
   ns=s1;
   else
   ns=s2;
   end
s2:begin
   if(din)
   ns=s3;
   else
   ns=idle;
   end
s3:begin
   if(din)
   ns=s1;
   else
   ns=idle;
   end
default :begin
         ns=idle;
         end
endcase
end
assign dout=(ps==s3)?1:0;
endmodule

test bench:
module tb;
reg clk,rst,din;
wire dout;
seq_101_moore dut(.clk(clk),.rst(rst),.din(din),.dout(dout));
initial begin
{clk,rst,din}=0;
end
always #5 clk=~clk;
initial begin
@(negedge clk)
rst=1;
@(negedge clk)
rst=0;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b0;
@(negedge clk)
din=1'b1;
end
endmodule


Seq_101(mealy):
module mealy_101(input clk,rst,din,output reg y);
parameter idle=2'b00;
parameter s1=2'b01;
parameter s2=2'b10;
parameter s3=2'b11;
reg [1:0]ns,ps;
always@(posedge clk)
begin
if(rst)
ps<=idle;
else
ps<=ns;
end
//next state logic
always@(*)
begin
case(ps)
idle:begin
     if(din)
     ns=s1;
     else
     ns=idle;
     end
s1:begin
   if(din)
   ns=s1;
   else
   ns=s2;
   end
s2:begin
   if(din)
   ns=idle;
   else
   ns=idle;
   end
default :begin
         ns=idle;
         end
endcase
end
always@(negedge clk)
begin
case(ps)
idle:y=0;
s1:y=0;
s2:begin
   if(din)
   y=1;
   else
   y=0;
   end
endcase
end
endmodule

test bench:
module tb1;
reg clk,rst,din;
wire y;
mealy_101 dut(.clk(clk),.rst(rst),.din(din),.y(y));
initial begin
{clk,rst,din}=0;
end
always #5 clk=~clk;
initial begin
@(negedge clk)
rst=1;
@(negedge clk)
rst=0;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b0;
@(negedge clk)
din=1'b1;
end
endmodule


Seq_1101(mealy_moore):
module seq_1101_det(input clk,rst,din,output  reg dout);
parameter idle =3'b000;
parameter s1=3'b001;
parameter s2=3'b010;
parameter s3=3'b011;
parameter s4=3'b100;
reg [2:0]ns,ps;
always@(posedge clk)
begin
if(rst)
ps<=idle;
else 
ps<=ns;
end
always@(*)
begin
case(ps)
idle:begin
     if(din)
     ns=s1;
     else
     ns=idle;
     end
s1:begin
   if(din)
   ns=s2;
   else
   ns=idle;
   end
s2:begin
   if(din)
   ns=s2;
   else
   ns=s3;
   end
s3:begin
   if(din)
   ns=s1;
   else
   ns=idle;
   end
//s3:begin
//   if(din)
//   ns=s4;
//   else
//   ns=idle;
//   end
//s4:begin
//   dout=1;
//   if(din)
//   ns=s2;
//   else
//   ns=idle;
  // end
default:begin
        ns=idle;
        end
endcase
end
//assign dout=(ps==s3)?1:0;
always@(posedge clk)
begin
case(ps)
s3:begin
   if(din)
   dout=1;
   else
   dout=0;
   end
endcase
end
endmodule

test bench:
module tb_1101;
reg clk,rst,din;
wire dout;
seq_1101_det dut(.clk(clk),.rst(rst),.din(din),.dout(dout));
initial begin
{clk,rst,din}=0;
end
always #5 clk=~clk;
initial begin
@(negedge clk)
rst=1;
#10
rst=0;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b0;
@(negedge clk)
din=1'b1;
end
endmodule


Seq_10110:
module seq_10110(input clk,rst,din,output dout);
parameter idle = 5'b00000;
parameter s1 = 5'b00001;
parameter s2 = 5'b00010;
parameter s3 = 5'b00011;
parameter s4 = 5'b00100;
parameter s5 = 5'b00101;
reg [4:0]ps,ns;
always@(posedge clk)begin
if(rst)
ps<=idle;
else 
ps<=ns;
end
always@(*)
begin
case(ps)
idle:begin
     if(din)
     ns=1;
     else
     ns=idle;
     end
s1:begin
    if(din)
    ns=s1;
    else
    ns=s2;
    end
s2:begin
   if(din)
   ns=s3;
   else
   ns=idle;
   end
s3:begin
   if(din)
   ns=s4;
   else
   ns=s3;
   end
s4:begin
   if(din)
   ns=s1;
   else
   ns=s5;
   end
s5:begin
   if(din)
   ns=s3;
   else
   ns=idle;
   end
endcase
end
assign dout=(ps==s5)?1:0;
endmodule

Test bench:
module seq_10110_tb;
reg clk,rst,din;
wire dout;
seq_10110 dut(clk,rst,din,dout);
initial begin
{clk,rst,din}=0;
end
always #5 clk=~clk;
initial begin
rst=1;
#10;
rst=0;
@(posedge clk)
din=1'b1;
@(posedge clk)
din=1'b0;
@(posedge clk)
din=1'b1;
@(posedge clk)
din=1'b1;
@(posedge clk)
din=1'b0;
@(posedge clk)
din=1'b1;
end
endmodule


Seq_toggle_1100:
module seq_toggle_1100(input clk,rst,din,output reg dout);
reg [2:0]ps,ns;
parameter idle=3'b000;
parameter s1=3'b001;
parameter s2=3'b010;
parameter s3=3'b011;
parameter s4=3'b100;
parameter s5=3'b101;
parameter s6=3'b110;
parameter s7=3'b111;
always@(posedge clk)
begin
if(rst)
ps<=idle;
else
ps<=ns;
end
always@(*)
begin
case(ps)
idle:begin
     if(din)
     ns=1;
     else
     ns=idle;
     end
s1:begin
   if(din)
   ns=s2;
   else
   ns=idle;
   end
s2:begin
   if(din)
   ns=s2;
   else
   ns=s3;
   end
s3:begin
   if(din)
   ns=s1;
   else
   ns=s4;
   end
s4:begin
   if(din)
   ns=s5;
   else
   ns=s4;
   end
s5:begin
   if(din)
   ns=s6;
   else
   ns=s4;
   end
s6:begin
   if(din)
   ns=s6;
   else
   ns=s7;
   end
s7:begin
   if(din)
   ns=s5;
   else
   ns=idle;
   end
default:begin
        ns=0;
        end
endcase
end
always@(posedge clk)
begin
if(rst)
dout<=0;
else if(ps==s3 && din==0)
dout<=~dout;
end
endmodule

Test bench:
module tb_tog;
reg clk,rst,din;
wire dout;
seq_toggle_1100 dut(.clk(clk),.rst(rst),.din(din),.dout(dout));
initial begin
{clk,rst,din}=0;
end
always #5 clk=~clk;
initial begin
@(negedge clk)
rst=1;
@(negedge clk)
rst=0;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b0;
@(negedge clk)
din=1'b0;
@(negedge clk)
rst=1;
@(negedge clk)
rst=0;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b1;
@(negedge clk)
din=1'b0;
@(negedge clk)
din=1'b0;
end
endmodule


